#pragma once

#include <atomic>
#include <limits>
#include <mutex>
#include <stdexcept>
#include <vector>

#include "glog/logging.h"
#include "hal/time/time.h"
#include "radio/radio_module.h"

namespace tvsc::radio {

template <size_t MTU>
class MockRadioT;

namespace internal {
/**
 * Helper class for simulating interrupts generated by radio hardware subsystems.
 *
 * This class triggers "transmitting" messages and "receiving" messages based on timing and
 * radio state.
 */
template <size_t MTU>
class RadioInterrupter final {
 private:
  MockRadioT<MTU>* radio_;

  std::atomic<bool> is_running_{false};
  std::atomic<bool> stop_requested_{false};

  uint64_t possibly_receive_fragment() {
    std::unique_lock<std::mutex> lock(radio_->mutex_);

    // Simulate an external radio broadcasting a fragment every fragment_receive_interval_ms_.
    // Note that this is independent of the mode of the radio. If the radio is not in RX
    // mode, this fragment gets dropped.
    if (!radio_->rx_fragments_.empty()) {
      DLOG(INFO) << "RadioInterrupter::possibly_receive_fragments() -- radio has "
                    "mocked fragments to receive";
      const uint64_t current_time_ms{tvsc::hal::time::time_millis()};
      if (radio_->last_receive_time_ms_ + MockRadioT<MTU>::fragment_receive_interval_ms >
          current_time_ms) {
        DLOG(INFO) << "RadioInterrupter::possibly_receive_fragments() -- radio "
                      "receiving mocked fragment.";
        lock.unlock();
        if (radio_->in_rx_mode()) {
          lock.lock();
          DLOG(INFO) << "RadioInterrupter::possibly_receive_fragments() -- radio "
                        "received mocked fragment.";
          DLOG(INFO) << "RadioInterrupter::possibly_receive_fragments() -- fragment: "
                     << to_string(radio_->rx_fragments_.front());
          radio_->buffered_fragment_ = radio_->rx_fragments_.front();
          radio_->have_fragment_from_rx_ = true;
        } else {
          lock.lock();
          DLOG(INFO) << "RadioInterrupter::possibly_receive_fragments() -- radio not "
                        "in rx mode. Dropping fragment.";
          ++radio_->count_dropped_fragments_;
        }
        radio_->rx_fragments_.erase(radio_->rx_fragments_.begin());
        radio_->last_receive_time_ms_ = current_time_ms;
      }

      return radio_->last_receive_time_ms_ + MockRadioT<MTU>::fragment_receive_interval_ms;
    } else {
      // No more fragments available to receive.
      return std::numeric_limits<uint64_t>::max();
    }
  }

  uint64_t possibly_transmit_fragment() {
    DLOG(INFO) << "RadioInterrupter::possibly_transmit_fragment()";
    std::unique_lock<std::mutex> lock(radio_->mutex_);
    if (radio_->have_fragment_for_tx_) {
      const uint64_t current_time_ms{tvsc::hal::time::time_millis()};
      if (radio_->last_switch_to_tx_mode_ms_ + MockRadioT<MTU>::fragment_transmit_time_ms >
          current_time_ms) {
        lock.unlock();
        if (radio_->in_tx_mode()) {
          lock.lock();
          radio_->sent_fragments_.emplace_back(radio_->buffered_fragment_);
        } else {
          lock.lock();
          ++radio_->count_corrupted_fragments_;
        }

        radio_->have_fragment_for_tx_ = false;

        // Need to switch out of TX mode, reload the buffer, and then back into TX mode to transmit
        // again.
        radio_->last_switch_to_tx_mode_ms_ = 0;
      } else {
        // We have a fragment to transmit, but we haven't held in TX mode long enough to transmit
        // it.
        return radio_->last_switch_to_tx_mode_ms_ + MockRadioT<MTU>::fragment_transmit_time_ms;
      }
    }

    // Fall-through on every case where we don't have a fragment to transmit at the moment, possibly
    // because we just transmitted one.
    return std::numeric_limits<uint64_t>::max();
  }

 public:
  RadioInterrupter(MockRadioT<MTU>& radio) : radio_(&radio) {}
  ~RadioInterrupter() {
    stop();

    // Block until the other thread, if any, stops, up to max_total_delay_ms.
    static constexpr uint32_t max_total_delay_ms{1000};
    uint32_t total_delay_ms{0};
    while (is_running_ && total_delay_ms < max_total_delay_ms) {
      static constexpr uint32_t incremental_delay_ms{5};
      total_delay_ms += incremental_delay_ms;
      tvsc::hal::time::delay_ms(incremental_delay_ms);
    }

    if (total_delay_ms >= max_total_delay_ms) {
      // We are very likely to crash in this case. It's likely the other thread is still running,
      // and it is referencing this object, but we are destroying this object now. Rather than crash
      // later, we force a failure now.
      LOG(FATAL)
          << "RadioInterrupter::~RadioInterrupter() -- could not stop secondary "
             "running thread. This will almost certainly cause a failure later as the other thread "
             "will still be referencing this object which is being destroyed. Aborting process.";
    }
  }

  /**
   * Performs the next task(s) based on the current time.
   *
   * Returns the time in ms when the next known task will be actionable.
   */
  uint64_t iterate() {
    // By default, wake up every 5ms.
    uint64_t next_action_time_ms{tvsc::hal::time::time_millis() + 5};

    // Transmit a fragment if appropriate, retrieving the next time to wake up to transmit a
    // fragment.
    const uint64_t next_transmit_time_ms{possibly_transmit_fragment()};

    // Receive a fragment if appropriate, retrieving the next time to wake up to receive a
    // fragment.
    const uint64_t next_receive_time_ms{possibly_receive_fragment()};

    next_action_time_ms =
        std::min({next_action_time_ms, next_transmit_time_ms, next_receive_time_ms});

    return next_action_time_ms;
  }

  /**
   * Runs the iterate method in a loop. This method is designed to be run in its own thread. It does
   * not return until the stop() method is called, again in a separate thread.
   */
  void start() {
    stop_requested_ = false;
    is_running_ = true;
    while (!stop_requested_) {
      const uint64_t next_action_time_ms{iterate()};
      const uint64_t current_time_ms{tvsc::hal::time::time_millis()};
      const uint64_t delay_amount_ms{next_action_time_ms - current_time_ms};

      // Note: the first check guarantees that the next_action_time_ms is in the future. It's
      // possible to return a next action time, get delayed, and then find that time is now in the
      // past. If that happens, the delay_amount_ms might be some very large number, and we would
      // effectively never wake back up. (This is why Google and the Java language don't use
      // unsigned integers; it's tricky to avoid these types of overflows.)
      if (next_action_time_ms > current_time_ms && delay_amount_ms < 100) {
        tvsc::hal::time::delay_ms(delay_amount_ms);
      } else {
        // Sleep for a small amount by default to avoid excessive CPU load.
        tvsc::hal::time::delay_ms(5);
      }
    }
    is_running_ = false;
  }

  /**
   * Stop the other thread, if any. Note that this method does not block, so the other thread may
   * not be stopped when this method returns.
   */
  void stop() { stop_requested_ = true; }
};

}  // namespace internal

template <size_t MTU>
class MockRadioT final : public HalfDuplexRadio<MTU> {
 private:
  // Amount of time in milliseconds in between fragment receptions. This simulates a time delay
  // between the reception of the various fragments. The radio will receive a fragment as long
  // as the radio is in RX mode when this timing triggers.
  static constexpr uint16_t fragment_receive_interval_ms{20};

  // Amount of time in milliseconds required to transmit a fragment, including ramping up and down
  // the amplifiers, DSP operations and DAC timing. The radio must stay continuously in TX
  // mode during this time.
  static constexpr uint16_t fragment_transmit_time_ms{15};

  mutable std::mutex mutex_{};

  // Timestamp of the last time a fragment was received. This should just increment in
  // fragment_receive_interval_ms increments and is used to figure out when the next fragment should
  // be received.
  uint64_t last_receive_time_ms_{};

  // Timestamp of the last time the radio switched into TX mode. In order to transmit a
  // fragment, we must be in TX mode for at least fragment_transmit_time_ms, else that fragment is
  // marked as corrupted.
  uint64_t last_switch_to_tx_mode_ms_{0};

  // Collection of fragments that will be "received" when read_received_fragment() is called.
  std::vector<Fragment<MTU>> rx_fragments_{};

  // Collection of fragments that have been sent via call to transmit_fragment().
  std::vector<Fragment<MTU>> sent_fragments_{};

  enum class Mode {
    STANDBY,
    RX,
    TX,
  };
  Mode current_mode_{Mode::STANDBY};

  // Count of fragments dropped due to infrequent reading.
  size_t count_dropped_fragments_{0};

  // Count of packets corrupted due to too frequent of transmissions or corrupted because we
  // switched out of TX mode before it was transmitted. If transmit_fragment(), set_receive_mode(),
  // set_standby_mode(), read_received_fragment() or possibly other functions are called before
  // fragment_transmit_time_ms after the previous call to transmit_fragment(), the previous fragment
  // is corrupted. Basically, half-duplex radios need time to finish their transmissions before they
  // can reconfigured for other tasks.
  size_t count_corrupted_fragments_{0};

  // Most radios we are working with only have storage for a single fragment. This may be the
  // fragment that was most recently received, or the fragment being transmitted. That means that
  // switching modes can drop/corrupt fragments.
  Fragment<MTU> buffered_fragment_{};

  bool have_fragment_from_rx_{false};
  bool have_fragment_for_tx_{false};

  std::unique_ptr<internal::RadioInterrupter<MTU>> interrupter_{};
  friend class internal::RadioInterrupter<MTU>;

  void corrupt_transmit_fragment() {
    if (in_tx_mode()) {
      const std::lock_guard<std::mutex> lock(mutex_);
      if (have_fragment_for_tx_) {
        ++count_corrupted_fragments_;
      }
    }
    const std::lock_guard<std::mutex> lock(mutex_);
    have_fragment_for_tx_ = false;
    last_switch_to_tx_mode_ms_ = 0;
  }

 public:
  /**
   * Start an async process/thread to simulate interrupts coming from various hardware subsystems.
   */
  void start_interrupts() {
    const std::lock_guard<std::mutex> lock(mutex_);

    last_receive_time_ms_ = tvsc::hal::time::time_millis();
    interrupter_ = std::make_unique<internal::RadioInterrupter<MTU>>(*this);
    auto t = std::thread(&internal::RadioInterrupter<MTU>::start, interrupter_.get());
    t.detach();
  }

  /**
   * Stop the interrupts.
   */
  void stop_interrupts() {
    if (interrupter_) {
      interrupter_->stop();
      // Note that this triggers the destructor of the current instance and stores a nullptr in
      // interrupter_ unique ptr.
      interrupter_.reset();
    }
    last_receive_time_ms_ = 0;
  }

  /**
   * Add a fragment to be received. This method helps configure the mock radio state.
   */
  void add_rx_fragment(const Fragment<MTU>& fragment) {
    const std::lock_guard<std::mutex> lock(mutex_);
    rx_fragments_.emplace_back(fragment);
  }

  size_t remaining_rx_fragment_count() const {
    const std::lock_guard<std::mutex> lock(mutex_);
    return rx_fragments_.size();
  }

  /**
   * Get collection of fragments that were transmitted successfully.
   */
  const std::vector<Fragment<MTU>>& sent_fragments() const {
    const std::lock_guard<std::mutex> lock(mutex_);
    return sent_fragments_;
  }

  size_t count_dropped_fragments() const {
    const std::lock_guard<std::mutex> lock(mutex_);
    return count_dropped_fragments_;
  }

  size_t count_corrupted_fragments() const {
    const std::lock_guard<std::mutex> lock(mutex_);
    return count_corrupted_fragments_;
  }

  bool in_standby_mode() const override {
    const std::lock_guard<std::mutex> lock(mutex_);
    return current_mode_ == Mode::STANDBY;
  }

  bool in_rx_mode() const override {
    const std::lock_guard<std::mutex> lock(mutex_);
    return current_mode_ == Mode::RX;
  }

  bool in_tx_mode() const override {
    const std::lock_guard<std::mutex> lock(mutex_);
    return current_mode_ == Mode::TX;
  }

  /**
   * Reset the radio back to a default state and in standby mode. This may include a hardware
   * reset, such as powering down the module and powering it back on again, toggling an enable or
   * reset line, etc.
   *
   * The constructor for the radio should put it in the same default state. This is easily
   * accomplished by calling reset() at the end of the constructor.
   *
   * This call should be idempotent.
   */
  void reset() override {
    {
      const std::lock_guard<std::mutex> lock(mutex_);
      buffered_fragment_.clear();
      have_fragment_from_rx_ = false;
    }
    stop_interrupts();
    set_standby_mode();
  }

  /**
   * Read the RSSI (Received Signal Strength Indicator) in dBm. Note that making this reading may
   * interrupt any ongoing rx or tx operation and will likely involve changing register values on
   * the radio.
   */
  float read_rssi_dbm() override {
    // Return a benign value for now. Consider adding logic to set different RSSI levels for mocking
    // different scenarios.
    return -85.f;
  }

  /**
   * Put the radio in a standby mode. Standby means that it is not receiving or transmitting.
   * This may be used to save power.
   *
   * This call should be idempotent.
   */
  void set_standby_mode() override {
    if (!in_standby_mode()) {
      corrupt_transmit_fragment();
      const std::lock_guard<std::mutex> lock(mutex_);
      current_mode_ = Mode::STANDBY;
    }
  }

  /**
   * Configure the radio to receive data.
   *
   * This call should be idempotent.
   */
  void set_receive_mode() override {
    if (!in_rx_mode()) {
      corrupt_transmit_fragment();
      const std::lock_guard<std::mutex> lock(mutex_);
      current_mode_ = Mode::RX;
    }
  }

  /**
   * Flag to poll if the radio has rx data available to read.
   */
  bool has_fragment_available() const override {
    const std::lock_guard<std::mutex> lock(mutex_);
    return have_fragment_from_rx_;
  }

  /**
   * Read a fragment that has already been received by the radio. After being read, the
   * radio will discard the fragment.
   */
  void read_received_fragment(Fragment<MTU>& fragment) override {
    const std::lock_guard<std::mutex> lock(mutex_);
    fragment = buffered_fragment_;
    have_fragment_from_rx_ = false;
  }

  /**
   * Flag to poll if the radio is detecting channel activity. Before transmitting, the
   * radio should wait until this activity has cleared.
   *
   * Note that this method cannot be marked const, since it likely involves reading the RSSI level
   * which will involve changing register values, disrupting any ongoing RX, etc.
   */
  bool channel_activity_detected() override {
    // Consider changing this to an RSSI threshold and making the RSSI level configurable for
    // testing.
    return false;
  }

  bool is_transmitting_fragment() override {
    std::unique_lock<std::mutex> lock(mutex_);
    return have_fragment_for_tx_;
  }

  /**
   * Transmit a fragment.
   *
   * Returns true if the transmission was initiated, false if it could not start within the timeout.
   * True does not guarantee that it was received.
   */
  bool transmit_fragment(const Fragment<MTU>& fragment, uint16_t timeout_ms) override {
    const uint64_t abandon_time_ms{tvsc::hal::time::time_millis() + timeout_ms};

    // Wait until we have a clear channel to transmit.
    while (channel_activity_detected() && tvsc::hal::time::time_millis() < abandon_time_ms) {
      tvsc::hal::time::delay_us(100);
    }
    if (tvsc::hal::time::time_millis() >= abandon_time_ms) {
      return false;
    }

    set_standby_mode();

    const std::lock_guard<std::mutex> lock(mutex_);
    buffered_fragment_ = fragment;
    have_fragment_for_tx_ = true;
    current_mode_ = Mode::TX;
    last_switch_to_tx_mode_ms_ = tvsc::hal::time::time_millis();
    return true;
  }
};

/**
 * Radio that has the same MTU as cheap hobbyist radios.
 */
using SmallBufferMockRadio = MockRadioT<65>;

using MockRadio = MockRadioT<256>;

/**
 * Radio that has the same MTU as most ethernet devices.
 */
using LargeBufferMockRadio = MockRadioT<1500>;

/**
 * Radio that has an MTU configured for jumbo ethernet frames.
 */
using JumboBufferMockRadio = MockRadioT<9000>;

}  // namespace tvsc::radio
